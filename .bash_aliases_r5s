#!/usr/bin/env bash

# file: ~/.bash_aliases_r5s - sourced by ~/.bashrc_aliases via $COMPANY_SHIT

# these are functions/aliases specific to Red 5 Studios

# shellcheck disable=SC1090,SC2034,SC2139,SC2142,SC1117

CO_BA_FILE=".bash_aliases_$COMPANY"

# if interactive shell - display message
[ -n "$PS1" ] && echo -n "$CO_BA_FILE(ðŸŸ¢) "

# set up some globals
#CHEF_REPO=/opt/repo
CHEF_REPO=$HOME/repos
REPO_DIR=$HOME/repos

# set value of OTHERVM for .bash_aliases syncing
if [ "$(hostname)" == "racos" ]; then
   export OTHERVM=racovm
else
   export OTHERVM=racos
fi

# -------------------- define functions --------------------

function showcof {
   # show a company specific function
   local _ALIASES_FILE="$HOME/$CO_BA_FILE"
   if [[ $1 ]]; then
      if grep -q "^function $1 " "$_ALIASES_FILE"; then
         sed -n '/^function '"$1"' /,/^}/p' "$_ALIASES_FILE"
      else
         echo "function: '$1' - not found"
      fi
   else
      echo
      echo "which function do you want to see?"
      grep "^function .* " "$_ALIASES_FILE" | awk '{print $2}' | cut -d'(' -f1 |  awk -v c=4 'BEGIN{print "\n\t--- Functions (use \`scof\` to show details) ---"}{if(NR%c){printf "  %-18s",$1}else{printf "  %-18s\n",$1}}END{print CR}'
      echo -ne "enter function: "
      read -r func
      echo
      showcof "$func"
   fi
}

function bon {
   # Bootstrap OpenStack Node
   if knife_env_set; then
      update_spiceweasel_repo
      sgp=$1
      nip=$2
      nn=$3
      if [ -n "$sgp" ] && [ -n "$nip" ]; then
         orig_cmd=$(spiceweasel "$SW_YAML_FILE" | \grep -w "$sgp" | sort -u)
         case $KNIFTLA in
            dtu|pew|pms|pue|puw|pte|ptu|rou)
               kbc=$(awk '{for (i=1;i<=NF;i++) {if ($i =="-r") {role=$(i+1)}; if ($i =="-N") {iname=$(i+1)}}; {print "knife bootstrap '"$nip"' -r "role" -c "$KNIFERB" -x praco -N "iname"'"$nn"' --sudo"}}' <<< "$orig_cmd")
               ;;
            ccd|pek|w11|w12|w13)
               if [ -n "$nn" ]; then
                  kbc=$(awk '{for (i=1;i<=NF;i++) {if ($i =="-r") {role=$(i+1)}; if ($i =="-N") {iname=$(i+1)}}; {print "knife bootstrap '"$nip"' -r "role" -c "$KNIFERB" -i ~/.ssh/Red5China.pem -x ubuntu -N "iname"'"$nn"' --sudo"}}' <<< "$orig_cmd")
                  kbc="${kbc} --bootstrap-url http://221.228.92.21:8080/chef/install.sh"
               else
                  echo -e "\t-----------------------------------------------------------------------"
                  echo "need to specify a <spiceweasel grep pattern>, <IP> and <node number>"
                  return 2
               fi
               ;;
            dts|sna)
               kbc=$(awk '{for (i=1;i<=NF;i++) {if ($i =="-r") {role=$(i+1)}; if ($i =="-N") {iname=$(i+1)}}; {print "knife bootstrap '"$nip"' -r "role" -c "$KNIFERB" -i ~/.ssh/Red5China.pem -x ubuntu -N "iname"'"$nn"' --sudo"}}' <<< "$orig_cmd")
               kbc="${kbc} --bootstrap-url http://115.182.10.10:8080/chef/install.sh"
               ;;
            *)
               echo "error: not sure how I got here"; return 2;;
         esac
         compare_lines "$orig_cmd" "$kbc"
         echo -e "\t-----------------------------------------------------------------------"
         read -rp "is this correct - do you want to run it (y/n)? " ans
         if [ "$ans" = "y" ]; then
            echo "ok, running the command"
            eval "$kbc"
         else
            echo "ok, NOT running the command"
         fi
      else
         echo "need to specify a <spiceweasel grep pattern> and <IP>"
      fi
   fi
}

function frlic {
   # find roles that I've changed
   cd "$CHEF_REPO/cookbooks" || return
   local _cookbook_dir
   for _cookbook_dir in *; do
      if [ -d "$_cookbook_dir" ]; then
         echo " ------- $_cookbook_dir -------"
         cd "$_cookbook_dir" || return
         hg stat
         hg shelve -l
      fi
   done
   cd - || return
}

function fsic {
   # find stuff that I've changed in the sub dirs of the cwd
   local _owd
   _owd=$(pwd)
   local _sub_dir
   for _sub_dir in *; do
      if [ -d "$_sub_dir" ]; then
         echo " ------- $_sub_dir -------"
         cd "$_sub_dir" || return
         hg stat
         hg shelve -l
      fi
   done
   cd "$_owd" || return
}

function fsip {
   # find stuff that I've pushed in the sub dirs of the cwd
   local _owd
   _owd=$(pwd)
   local _sub_dir
   for _sub_dir in $(/bin/ls); do
      if [ -d "$_sub_dir" ]; then
         echo " ------- $_sub_dir -------"
         cd "$_sub_dir" || return
         hg slog | grep Raco
      fi
   done
   cd "$_owd" || return
}

function hgd {
   # show mecurial diff
   local _rev=$1
   echo "hg diff -r $((--_rev)) -r $((++_rev))"
   hg diff -r $((--_rev)) -r $((++_rev))
}

function kcl {
   # preform a client node list (and optionally grep for a pattern)
   if knife_env_set; then
      if [ -n "$1" ]; then
         chef_clients=$(knife client list -c "$KNIFERB" | grep "$@")
         if [ -n "$chef_clients" ]; then
            echo "$chef_clients"
         else
            echo "did not find any nodes matching '$1' in the client list"
         fi
      else
         chef_clients_nc=$(knife client list -c "$KNIFERB")
         if [ -n "$chef_clients_nc" ]; then
            echo "$chef_clients_nc"
         else
            echo "could not find any clients to list"
         fi
      fi
   fi
}

function kcn {
   # knife Create Node - using spiceweasel
   sgp=$1
   shift
   arg=$1
   while [ -n "$arg" ]; do
      shift
      case $arg in
         '-b') build=$1 ;;
         '-n') nn=$1    ;;
         '-z') zone=$1  ;;
      esac
      shift
      arg=$1
   done
   if knife_env_set; then
      update_spiceweasel_repo
      if [ -n "$sgp" ]; then
         orig_cmd=$(spiceweasel "$SW_YAML_FILE" | \grep -w "$sgp" | sort -u)
         case $KNIFTLA in
            dtu|pte|ptu|rou)
               kscc=${orig_cmd//-c .chef\/knife.rb/-c $KNIFERB}
               if [[ $sgp =~ "game" ]]; then
                  if [ -n "$build" ]; then
                     kscc=$(sed "s:XXXX:$build:g;s:$sgp-$nn$build-:$sgp-$build-$nn:" <<< "$kscc")
                  else
                     echo -e "\t-----------------------------------------------------------------------"
                     echo "need to specify a <spiceweasel grep pattern> and <build number>"
                     return 2
                  fi
               fi
               ;;
            pew|pms|pue|puw)
               kscc=${orig_cmd//-c .chef\/knife.rb/-c $KNIFERB}
               if [[ $sgp =~ "game" ]]; then
                  if [ -n "$build" ]; then
                     kscc=$(sed "s:XXXX:$build:g;s:$sgp-$nn$build-:$sgp-$build-$nn:" <<< "$kscc")
                  else
                     echo -e "\t-----------------------------------------------------------------------"
                     echo "need to specify a <spiceweasel grep pattern> and <build number>"
                     return 2
                  fi
               fi
               ;;
            ccd|dts|pek|sna|w11|w12|w13)
               if [ -n "$nn" ] && [ -n "$zone" ]; then
                  # shellcheck disable=SC2016
                  kscc=$(sed "s:-c .chef/knife.rb:-c "'$KNIFERB'":;s:$sgp-:$sgp-$nn:;s: -T Group=Internal::;s: -g: -G:;s:vNN-ZONE-X:$zone:" <<< "$orig_cmd")
               else
                  if [[ $sgp =~ "matchdirector" && -n "$zone" ]]; then
                     # shellcheck disable=SC2016
                     kscc=$(echo "$orig_cmd" | sed "s:-c .chef/knife.rb:-c "'$KNIFERB'":;s: -T Group=Internal::;s: -g: -G:;s:vNN-ZONE-X:$zone:")
                  else
                     echo -e "\t-----------------------------------------------------------------------"
                     echo "need to specify a <spiceweasel grep pattern>, <node number> and <zone-id>"
                     return 2
                  fi
               fi
               if [[ $sgp =~ "game" ]]; then
                  if [ -n "$build" ]; then
                     kscc=$(echo "$kscc" | sed "s:XXXX:$build:g;s:$sgp-$nn$build-:$sgp-$build-$nn:")
                  else
                     echo -e "\t-----------------------------------------------------------------------"
                     echo "need to specify a <spiceweasel grep pattern>, <node number>, <zone-id> and <build number>"
                     return 2
                  fi
               fi
               ;;
            *)
               echo "error: not sure how I got here"; return 2;;
         esac
         compare_lines "$orig_cmd" "$kscc"
         echo -e "\t-----------------------------------------------------------------------"
         read -rp "is this correct - do you want to run it (y/n/x)? " ans
         if [ "$ans" = "y" ]; then
            echo "ok, running the command"
            eval "$kscc"
         elif [ "$ans" = "x" ]; then
            echo "ok, running the command in a xterm window"
            #xterm -e "echo $kscc;eval $kscc;echo $kscc;bash" &
            $XTERM -e 'echo '"$kscc"';eval '"$kscc"';echo '"$kscc"';bash' &
         else
            echo "ok, NOT running the command"
         fi
      else
         echo "need to specify a <spiceweasel grep pattern>"
      fi
   fi
}

function kcssh {
   # cssh to servers matching PATTERN provided by user via `knife ssh`
   # and internal FQDN's
   if knife_env_set; then
      source_ssh_env
      servers=$1
      eval knife ssh "name:*${servers}*" -a internal_fqdn cssh -c "$KNIFERB"
   fi
}

function kcssha {
   # cssh to servers matching multiple PATTERNs provided
   # via `knife node list` and `cssh`
   local fqdn_srvr_list
   if knife_env_set; then
      knife_node_list=$(mktemp /tmp/knl.XXXX)
      knife node list -c "$KNIFERB" > "$knife_node_list"
      for server_pattern in "$@"; do
         #echo "server_pattern=$server_pattern"
         echo "looking for servers matching '$server_pattern'"
         # shellcheck disable=SC2013
         for actual_server in $(\grep "$server_pattern" "$knife_node_list"); do
            actual_server_ifqdn=$(knife node show -a internal_fqdn -c "$KNIFERB" "$actual_server" | \grep fqdn | awk '{print $2}')
            echo "found: $actual_server ($actual_server_ifqdn)"
            fqdn_srvr_list="$fqdn_srvr_list $actual_server_ifqdn"
         done
      done
      if [ -n "$fqdn_srvr_list" ]; then
         # get rid of dups
         # shellcheck disable=SC2086
         fqdn_srvr_list=$(for fqdns in $fqdn_srvr_list;do echo $fqdns;done|sort -u)
         cssh "$fqdn_srvr_list" &
      else
         echo "no servers found"
      fi
      rm -f "$knife_node_list"
   fi
}

function kcsshau {
   # cssh to servers matching multiple PATTERNs provided
   # via `knife node list` and `cssh`
   local fqdn_srvr_list
   if knife_env_set; then
      knife_node_list=$(mktemp /tmp/knl.XXXX)
      knife node list -c "$KNIFERB" > "$knife_node_list"
      for server_pattern in "$@"; do
         echo "looking for servers matching '$server_pattern'"
         # shellcheck disable=SC2013
         for actual_server in $(\grep "$server_pattern" "$knife_node_list"); do
            actual_server_ifqdn=$(knife node show -a internal_fqdn -c "$KNIFERB" "$actual_server" | \grep fqdn | awk '{print $2}')
            echo "found: $actual_server ($actual_server_ifqdn)"
            fqdn_srvr_list="$fqdn_srvr_list $actual_server_ifqdn"
         done
      done
      case $KNIFTLA in
         ccd|pek|w11|w12|w13) ssh_identy_file=~/.ssh/Red5China.pem     ;;
                           *) ssh_identy_file=~/.ssh/Red5Community.pem ;;
      esac
      if [ -n "$fqdn_srvr_list" ]; then
         # shellcheck disable=SC2086
         fqdn_srvr_list=$(for fqdns in $fqdn_srvr_list;do echo $fqdns;done|sort -u)
         cssh -l ubuntu -o "-i $ssh_identy_file" "$fqdn_srvr_list" &
      else
         echo "no servers found"
      fi
      rm -f "$knife_node_list"
   fi
}

function kcsshi {
   # cssh to servers matching PATTERN provided by user
   # via `knife ssh` and IP addresses
   if knife_env_set; then
      source_ssh_env
      servers=$1
      eval knife ssh "name:*${servers}*" -a ipaddress cssh -c "$KNIFERB"
   fi
}

function kcsshu {
   # cssh to servers matching PATTERN provided by user
   # via `knife ssh` and as ubuntu
   if knife_env_set; then
      source_ssh_env
      servers=$1
      case $KNIFTLA in
         ccd|pek|w11|w12|w13) ssh_identy_file=~/.ssh/Red5China.pem     ;;
                         sna) ssh_identy_file=~/.ssh/Red5Community.pem ;;
                         dts) ssh_identy_file=~/.ssh/Red5DevTest.pem   ;;
                           *) ssh_identy_file=~/.ssh/Red5Community.pem ;;
      esac
      eval knife ssh "name:*${servers}*" -u ubuntu -i $ssh_identy_file -a ipaddress cssh -c "$KNIFERB"
   fi
}

function kcurla {
   # usage: kcurla PATTERN
   # curl to servers matching multiple PATTERNs provided
   # via `knife node list` to check their health/build status
   local fqdn_srvr_list
   if knife_env_set; then
      knife_node_list=$(mktemp /tmp/knl.XXXX)
      knife node list -c "$KNIFERB" > "$knife_node_list"
      for server_pattern in "$@"; do
         # echo "debug: looking for servers matching '$server_pattern'"
         # shellcheck disable=SC2013
         for actual_server in $(\grep "$server_pattern" "$knife_node_list"); do
            actual_server_ifqdn=$(knife node show -a internal_fqdn -c "$KNIFERB" "$actual_server" | \grep fqdn | awk '{print $2}')
            # echo "debug: found: $actual_server ($actual_server_ifqdn)"
            fqdn_srvr_list="$fqdn_srvr_list $actual_server_ifqdn"
         done
      done
      if [ -n "$fqdn_srvr_list" ]; then
         # shellcheck disable=SC2086
         fqdn_srvr_list=$(for fqdns in $fqdn_srvr_list;do echo $fqdns;done|sort -u)
         for srvr in $fqdn_srvr_list; do
            echo -n "$srvr: "
            eval curl -qs "$fqdn_srvr_list/health" | sed 's/<.*>//'
            echo -n ": "
            eval curl -qs "$fqdn_srvr_list/build_info" | sed 's/<.*>//'; echo
         done
      else
         echo "no servers found"
      fi
      rm -f "$knife_node_list"
   fi
}

function kesd {
   # knife ec2 server delete
   if knife_env_set; then
      ans="n"
      if [ -n "$1" ]; then
         if [ "$1" == "-y" ]; then
            ans="y"
            shift
            if [ -n "$1" ]; then
               server=$1
            else
               echo "you need to specify a server to delete"
               return 1
            fi
         else
            server=$1
         fi
         inst_id=$(knife node show "$server" -a ec2.instance_id -c "$KNIFERB" | \grep -F "instance_id:" | awk '{print $2}')
         if [ -z "$inst_id" ]; then
            inst=$(cut -d- -f3 <<< "$server")
            inst_id="i-$inst"
         fi
         echo "here's the command:"
         echo "	knife ec2 server delete -y -R --purge --node $server $inst_id -c \$KNIFERB"
         [ "$ans" == "n" ] && read -rp "is this correct? " ans
         if [ "$ans" = "y" ]; then
            echo "ok, running the command"
            knife ec2 server delete -y -R --purge --node "$server" "$inst_id" -c "$KNIFERB"
         else
            echo "ok, NOT running the command"
         fi
      else
         echo "you need to specify a server to delete"
      fi
   fi
}

function kf {
   # `knife` command wrapper to use my dynamically set knife.rb file
   if [ -z "$KNIFERB" ]; then
      echo "chef/knife environment NOT set - use 'ske'"
   else
      eval knife '$*' -c "$KNIFERB"
   fi
}

function knife_env_set {
   # check if knife environment set (specifically the knife.rb file)
   if [ -z "$KNIFERB" ]; then
      echo "chef/knife environment NOT set - use 'ske'"
      return 1
   else
      return 0
   fi
}

function knl {
   # preform a knife node list (and optionally grep for a pattern)
   if knife_env_set; then
      if [ -n "$1" ]; then
         chef_nodes=$(knife node list -c "$KNIFERB" | grep "$@")
         if [ -n "$chef_nodes" ]; then
            echo "$chef_nodes"
         else
            echo "did not find any nodes matching '$1' in the node list"
         fi
      else
         chef_nodes_nc=$(knife node list -c "$KNIFERB")
         if [ -n "$chef_nodes_nc" ]; then
            echo "$chef_nodes_nc"
         else
            echo "could not find any nodes to list"
         fi
      fi
   fi
}

function kns {
   # perform knife node show for one or more node and optional specify
   # an attribute you can give -a option to show only one attribute
   if knife_env_set; then
      local _chef_node_nc
      local _chef_node
      local attrib
      local l_opt
      if [ "$1" = "-a" ]; then
         case $2 in
             az) attrib=firefall.availability_zone ;;
             bn) attrib=r5_build_number ;;
             fq) attrib=fqdn ;;
            ifq) attrib=internal_fqdn ;;
             ip) attrib=ipaddress ;;
              *) attrib=$2 ;;
         esac
         shift 2
      elif [ "$1" = "-l" ]; then
         l_opt="$1"
         shift
      fi
      if [ -n "$1" ]; then
         chef_nodes_nc=$(knife node list -c "$KNIFERB" | \grep "$@")
      else
         chef_nodes_nc=$(knife node list -c "$KNIFERB")
      fi
      if [ -n "$chef_nodes_nc" ]; then
         for _chef_node_nc in $chef_nodes_nc; do
            [ -n "$*" ] && _chef_node=$(grep "$@" <<< "$_chef_node_nc")
            echo -e "\t\t\t-----  $_chef_node  -----"
            if [ -n "$attrib" ]; then
               knife node show -c "$KNIFERB" "$_chef_node_nc" -a "$attrib"
            else
               knife node show -c "$KNIFERB" "$_chef_node_nc" "$l_opt"
            fi
         done
      else
         if [ -n "$1" ]; then
            echo "did not find any nodes matching '$1' to show"
         else
            echo "could not find any nodes to show"
         fi
      fi
   fi
}

function knsc {
   # find the creator of one or more nodes
   if knife_env_set; then
      for srvr in $(knife node list -c "$KNIFERB" | \grep "$1"); do
         echo -n "$srvr:	"
         knife node show "$srvr" -c "$KNIFERB" -a Creator
      done
   fi
}

function kosd {
   # knife openstack server delete
   if knife_env_set; then
      if [ -n "$1" ]; then
         server=$1
         #echo "here's the command:"
         echo -n "run this?: 'knife openstack server delete $server -y --purge -c \$KNIFERB' [y/n]: "
         #read -rp "is this correct? " ans
         read -r ans
         if [ "$ans" = "y" ]; then
            echo "ok, running the command"
            knife openstack server delete "$server" -y --purge -c "$KNIFERB"
         else
            echo "ok, NOT running the command"
         fi
      else
         echo "you need to specify a server to delete"
      fi
   fi
}

function kscp {
   # perform `scp` using knife to get IP's of hosts given via a pattern
   declare -A from_servers_ips
   declare -A to_servers_ips
   local multiple_froms=false
   local multiple_tos=false
   if knife_env_set; then
      if [[ $* =~ : ]]; then
         knife_node_list=$(mktemp /tmp/knl.XXXX)
         knife node list -c "$KNIFERB" > "$knife_node_list"
      fi
      if [ -n "$1" ] && [ -n "$2" ]; then
         if [[ $1 =~ : ]]; then
            fromserver=$(cut -d: -f1 <<< "$1")
            from_server_nc=$(\grep "$fromserver" "$knife_node_list" | awk '{print $1}')
            nos=$(echo "$from_server_nc" | wc -w)
            if [ "$nos" -gt 1 ]; then
               multiple_froms=true
               for _fs in $from_server_nc; do
                  from_servers_ips[$_fs]=$(knife node show -a ipaddress "$_fs" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
               done
            else
               multiple_froms=false
               from_server=$from_server_nc
               from_server_ip=$(knife node show -a ipaddress "$from_server" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
            fi
            from_file=$(cut -d: -f2 <<< "$1")
            ffc=":"
         else
            from_server=""
            from_server_ip=""
            from_file="$1"
            ffc=""
         fi
         if [[ $2 =~ : ]]; then
            toserver=$(cut -d: -f1 <<< "$2")
            to_server_nc=$(\grep "$toserver" "$knife_node_list" | awk '{print $1}')
            nos=$(echo "$to_server_nc" | wc -l)
            if [ "$nos" -gt 1 ]; then
               multiple_tos=true
               for _ts in $to_server_nc; do
                  to_servers_ips[$_ts]=$(knife node show -a ipaddress "$_ts" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
               done
            else
               multiple_tos=false
               to_server=$to_server_nc
               to_server_ip=$(knife node show -a ipaddress "$to_server" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
            fi
            to_file=$(echo "$2" | cut -d: -f2)
            tfc=":"
         else
            to_server=""
            to_server_ip=""
            to_file="$2"
            tfc=""
         fi
         if [ "$multiple_froms" = "true" ] && [ "$multiple_tos" = "true" ]; then
            for _fs in $from_server_nc; do
               for _ts in $to_server_nc; do
                  echo "scp $_fs(${from_servers_ips[$_fs]}):$from_file $_ts(${to_servers_ips[$_ts]}):$to_file.$_fs" | grep -E "$fromserver|$toserver"
                  scp "${from_servers_ips[$_fs]}:$from_file" "${to_servers_ips[$_ts]}:$to_file.$_fs"
               done
            done
         elif [ "$multiple_froms" = "true" ]; then
            for _fs in $from_server_nc; do
               if [ -n "$to_server" ]; then
                  echo "scp $_fs(${from_servers_ips[$_fs]}):$from_file $to_server($to_server_ip):$to_file.$_fs" | grep -E "$fromserver|$toserver"
                  scp "${from_servers_ips[$_fs]}:$from_file" "$to_server_ip:$to_file.$_fs"
               else
                  echo "scp $_fs(${from_servers_ips[$_fs]}):$from_file $to_file.$_fs" | grep "$fromserver"
                  scp "${from_servers_ips[$_fs]}:$from_file" "$to_file.$_fs"
               fi
            done
         elif [ "$multiple_tos" = "true" ]; then
            for _ts in $to_server_nc; do
               if [ -n "$from_server" ]; then
                  echo "scp $from_server($from_server_ip):$from_file $_ts(${to_servers_ips[$_ts]}):$to_file" | grep -E "$toserver|$toserver"
                  scp "$from_server_ip:$from_file" "${to_servers_ips[$_ts]}:$to_file"
               else
                  echo "scp $from_file $_ts(${to_servers_ips[$_ts]}):$to_file" | grep "$toserver"
                  scp "$from_file" "${to_servers_ips[$_ts]}:$to_file"
               fi
            done
         else
            if [ -n "$from_server" ] && [ -n "$to_server" ]; then
               echo "scp $from_server($from_server_ip):$from_file $to_server($to_server_ip):$to_file" | grep -E "$fromserver|$toserver"
            elif [ -n "$from_server" ]; then
               echo "scp $from_server($from_server_ip):$from_file $to_file" | grep "$fromserver"
            elif [ -n "$to_server" ]; then
               echo "scp $from_file $to_server($to_server_ip):$to_file" | grep "$toserver"
            else
               echo "scp $from_file $to_file"
            fi
            scp "$from_server_ip$ffc$from_file" "$to_server_ip$tfc$to_file"
         fi
         rm -f "$knife_node_list"
      else
         echo "error: you have to specify a SOURCE and DEST"
      fi
  fi
}

function kssh {
   # ssh into a server matching a pattern or run a command on it if given
   if knife_env_set; then
      serverpattern=$1
      shift
      cmd="$*"
      source_ssh_env
      server=$(knife node list -c "$KNIFERB" | \grep "$serverpattern")
      if [ $? -eq 1 ]; then
         echo "server not found (via 'knife node list')"
         return 2
      fi
      nos=$(echo "$server" | wc -l)
      if [ "$nos" -gt 1 ]; then
         sai=0
         echo "which server?"
         for srvr in $server; do
            ((sai++))
            echo "	$sai: $srvr"
            server_array[$sai]=$srvr
         done
         echo "	a: all | n-m: range | x,y: select"
         read -rp "enter choice (1-$sai|a|n-m|x,y): " choice
         if [ -n "$choice" ]; then
            if [ "$choice" = a ]; then
               kssha -l "$server" "$cmd"
               return 0
            elif [[ $choice =~ ^[0-9]+-[0-9]+$ ]]; then
               s_n=${choice%-*}
               s_m=${choice#*-}
               tsl=""  # the server list
               for i in $(seq "$s_n" "$s_m"); do
                  [ -z "$tsl" ] && tsl="${server_array[$i]}" || tsl="$tsl ${server_array[$i]}"
               done
               #echo "debug: 'kssha -l \"$tsl\" \"\$cmd\"'"
               kssha -l "$tsl" "$cmd"
               ## couldn't get this to work
               ##choice=":$(echo $choice | tr '-' ':')"
               ##echo "debug: 'kssha -l \"${server_array[@]choice}\" \"$cmd\"'"
               ##kssha -l "${server_array[@]:choice}" "$cmd"
               return 0
            elif [[ $choice =~ ^[0-9]+(,[0-9]+)+ ]]; then
               tsl=""  # the server list
               for i in $(tr ',' ' ' <<< "$choice"); do
                  [ -z "$tsl" ] && tsl="${server_array[$i]}" || tsl="$tsl ${server_array[$i]}"
               done
               #echo "debug: 'kssha -l \"$tsl\" \"\$cmd\"'"
               kssha -l "$tsl" "$cmd"
               return 0
            elif grep -q "[b-zA-Z]" <<< "$choice"; then
               echo "seriously?"
               return 3
            elif [ "$choice" -gt 0 ] && [ "$choice" -le "$sai" ]; then
               server=${server_array[$choice]}
            else
               echo "seriously?"
               return 3
            fi
         else
            echo "later..."
            return 5
         fi
      fi
      # shellcheck disable=SC2116,SC2086
      server=$(echo $server)  # get rid of leading whitespace and color
      # echo "debug: server='$server'"
      server_ifqdn=$(knife node show "$server" -a internal_fqdn -c "$KNIFERB" | grep internal_fqdn | awk '{print $NF}')
      # echo "debug: server_ifqdn='$server_ifqdn'"
      server_ip=$(host "$server_ifqdn" 2>/dev/null| awk '{print $NF}')
      # echo "debug: server_ip='$server_ip'"
      if [[ ! $server_ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
         echo "debug: couldn't get IP with 'host' (DNS) for < $server > - using 'knife'"
         server_ip=$(knife node show "$server" -a ipaddress -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
      fi
      #echo $server_ip | egrep -q '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
      #if [ $? -eq 0 ]; then
      if [[ $server_ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
         # don't do this for now - maybe later or with a smaller version of .bash_aliases
         ##if [ -z "$cmd" ]; then
         ##   scp -q ~/.{vim,bash}{rc,_aliases,_profile} $server_ip:/home/praco 2> /dev/null
         ##fi
         #[ -z "$cmd" ] && echo -e "	${CYN}< $server > [ $server_ip ]${NRM}" || echo -e "	${CYN}< $server > [ $server_ip ] ( $cmd )${NRM}"
         #[ -z "$cmd" ] && echo -e "	${CYN}$server ($server_ip)${NRM}" || echo -e "	${CYN}< $server > ( $server_ip ) [ $cmd ]${NRM}"
         if [ -z "$cmd" ] || [ "$cmd" == "." ]; then
            echo -e "	${CYN}$server ($server_ip)${NRM}"
            if [ "$cmd" == "." ]; then
               ssh -q "$server_ip"
            else
               $XTERM -e 'eval ssh -q '"$server_ip"'' &
            fi
         else
            echo -e "	${CYN}< $server > ( $server_ip ) [ $cmd ]${NRM}"
            eval ssh -q "$server_ip" "$cmd"
         fi
         echo -ne "\033]0;$(whoami)@$(hostname)\007"
      else
         echo "error: cannot get IP for server: < $server >"
      fi
   fi
}

function kssha {
   # run a command on multiple servers matching a given pattern
   # options
   #   -a   run on all servers
   #   -l   run on this list of servers
   #   -q   run quietly - less verbose - output on single lines
   if [ "$1" == "-q" ]; then
      QUIET=true
      shift
   else
      QUIET=false
   fi
   if [ "$1" == "-a" ]; then
      local _ALL=true
      shift
   else
      local _ALL=false
   fi
   if [ "$1" == "-l" ]; then
      shift
      server_list=$1
      shift
   else
      server_list=""
   fi
   if knife_env_set; then
      source_ssh_env
      if [ -z "$server_list" ]; then
         if [ "$_ALL" = "true" ]; then
            server_list=$(knife node list -c "$KNIFERB")
         else
            serverpattern="$1"
            shift
            server_list=$(knife node list -c "$KNIFERB" | \grep "$serverpattern")
         fi
      fi
      cmd="$*"
      #echo "debug(kssha): server_list='$server_list'"
      #echo "debug(kssha): cmd='$cmd'"
      if [ -n "$cmd" ]; then
         for server in $server_list; do
            # shellcheck disable=SC2116,SC2086
            server=$(echo $server)  # get rid of leading whitespace and color
            server_ifqdn=$(knife node show "$server" -a internal_fqdn -c "$KNIFERB" | grep internal_fqdn | awk '{print $NF}')
            server_ip=$(host "$server_ifqdn" 2>/dev/null | awk '{print $NF}')
            #echo $server_ip | egrep -q '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
            #if [ $? -ne 0 ]; then
            if [[ ! $server_ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
               echo "debug: couldn't get IP with 'host' (DNS) for < $server > - using 'knife'"
               server_ip=$(knife node show "$server" -a ipaddress -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
            fi
            #echo $server_ip | egrep -q '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
            #if [ $? -eq 0 ]; then
            if [[ $server_ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
               if [ $QUIET == "true" ]; then
                  #echo -n "$server ($server_ip) [$cmd]: "
                  echo -ne "${CYN}$server ($server_ip)${NRM}: "
               else
                  echo -e "	${CYN}< $server > ( $server_ip ) [ $cmd ]${NRM}"
               fi
               ##ssh $server_ip "$cmd"
               #eval ssh $server_ip "$cmd" 2> /dev/null
               eval ssh -q "$server_ip" "$cmd" && echo
            else
               echo "error: cannot get IP for server: < $server >"
            fi
         done
      else
         #kcssh $serverpattern
         kcssha "$server_list"
         return 0
      fi
   fi
}

function ksshu {
   # ssh as ubuntu into a server using knife to get the IP
   if knife_env_set; then
      source_ssh_env
      server=$(knife node list -c "$KNIFERB" | \grep "$1")
      nos=$(wc -l <<< "$server")
      if [ "$nos" -gt 1 ]; then
         echo "please be more specific:"
         grep "$1" <<< "$server"
         return
      fi
      # shellcheck disable=SC2116,SC2086
      server=$(echo $server)        # get rid of leading whitespace and color
      server_ip=$(knife node show -a ipaddress "$server" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}'|tr -d '\n')
      shift
      cmd="$*"
      case $KNIFTLA in
         ccd|pek|w11|w12|w13) ssh_identy_file=~/.ssh/Red5China.pem      ;;
                         dts) ssh_identy_file=~/.ssh/Red5DevTest.pem    ;;
                         sna) ssh_identy_file=~/.ssh/Red5PublicTest.pem ;;
                           *) ssh_identy_file=~/.ssh/Red5Community.pem  ;;
      esac
      echo "ssh -i $ssh_identy_file ubuntu@$server_ip \"$cmd\""
      #ssh -i ~/.ssh/Red5China.pem ubuntu@$server_ip "$cmd" 2> /dev/null
      ssh -q -i "$ssh_identy_file" "ubuntu@$server_ip" "$cmd"
      echo -ne "\033]0;$(whoami)@$(hostname)\007"
   fi
}

function oav {
   # OpenStack attach a VIP (and optional FIP)
   #
   # Usage: oav [-f] <instance> <last octet of vip>
   # Option: -f  Create and attach a FIP to the VIP
   local pcsgo
   if [ -z "$OS_PASSWORD" ] || [ -z "$OS_AUTH_URL" ] || [ -z "$OS_USERNAME" ] || [ -z "$OS_TENANT_NAME" ]; then
      echo "error: all of the OpenStack Environment variables aren't set"
      return 2
   fi
   if [ "$1" = "-f" ]; then
      afip="true"
      shift
   else
      afip="false"
   fi
   instance=$1
   loov=$2
   if [ -n "$instance" ] && [ -n "$loov" ]; then
      if instance_interfaces=$(nova interface-list "$instance" | \grep ACTIVE); then
         instance_portid=$(awk '{print $4}' <<< "$instance_interfaces")
         instance_netid=$(awk '{print $6}' <<< "$instance_interfaces")
         instance_ip=$(awk '{print $8}' <<< "$instance_interfaces")
         iilo=$(cut -d'.' -f4 <<< "$instance_ip")  #instance_ip_last_octect
         # shellcheck disable=SC2001
         vip=$(sed 's/.'"$iilo"'$/.'"$loov"'/' <<< "$instance_ip")
         # shellcheck disable=SC2086
         if vippll=$(neutron port-list | \grep -F '"'$vip'"'); then
            echo "creating VIP $vip with the following command:"
            for isg in $(nova list-secgroup $instance | \grep -Ev 'Id.*Name.*Description|------+------'|awk '{print $2}'); do
               [ -n "$isg" ] && pcsgo="$pcsgo --security-group $isg"
            done
            echo "  neutron port-create --fixed-ip ip_address=$vip $pcsgo $instance_netid"
            ##vipid=test_vipid ##debug##
            vipid=$(neutron port-create --fixed-ip ip_address=$vip $pcsgo $instance_netid | \grep -F "| id " | awk '{print $4}')
         else
            echo "the VIP $vip already exists"
            vipid=$(echo $vippll | awk '{print $2}')
         fi
         # shellcheck disable=SC2086
         if ipsal=$(neutron port-show "$instance_portid" | \grep -F allowed_address_pairs | \grep -F '"'$vip'"'); then
            echo "allowing the VIP to send traffic to the instance with the following command:"
            echo "  neutron port-update $instance_portid --allowed_address_pairs list=true type=dict ip_address=$vip"
            neutron port-update $instance_portid --allowed_address_pairs list=true type=dict ip_address=$vip
         else
            echo "the VIP is already allowed to send traffic to the instance"
            echo "  $ipsal"
         fi
         if [ "$afip" = "true" ]; then
            if fipll=$(neutron floatingip-list | \grep -F " $vip "); then
               echo "creating a FIP with the following command:"
               echo "  neutron floatingip-create net04_ext"
               ##fipid=test_fipid ##debug##
               fipid=$(neutron floatingip-create net04_ext | \grep -F "| id " | awk '{print $4}')
               echo "attaching a FIP using the following command"
               echo "  neutron floatingip-associate $fipid $vipid"
               ##fip=$(neutron floatingip-associate $fipid $vipid | \fgrep "| id " | awk '{print $4}')
               neutron floatingip-associate "$fipid" "$vipid" > /dev/null
               fip=$(neutron floatingip-list | \grep -F "$fipid" | awk '{print $6}')
               echo "VIP ($vip) is now attached to FIP ($fip)"
            else
               fip=$(awk '{print $6}' <<< "$fipll")
               echo "VIP ($vip) is already attached to FIP ($fip)"
            fi
         else
            echo "not creating a FIP or attaching it to the VIP"
         fi
      else
         echo "cannot get the interface info for instance: $instance"
      fi
   else
      echo "error: you did not specify an instance to attach the VIP to and last ip octet for the VIP"
   fi
}

function s3 {
   # `s3cmd` command wrapper to use my dynamically set s3cfg file
   #if [ -z "$KNIFERB" ]; then
   if [ -z "$AWSENV" ]; then
      #echo "chef/knife environment NOT set - use 'ske'"
      echo "AWS environment NOT set - use 'sae'"
   else
      eval s3cmd -c "$S3CFG" '$*'
   fi
}

function ske {
   # set knife environment
   local REPO=$CHEF_REPO
   local CHEF=$REPO/.chef
   local arg="$1"
   local SPICEWEASELREPO=$REPO_DIR/spiceweasel

   if [ -n "$arg" ]; then
      case $arg in
         ccd) akrb="knife_pek01_censorship.rb";     aenv="China Censorship Destra DNA"
              s3cg="$HOME/.s3cfg.pek01-censorship"; osrc="$HOME/.ccd.openstackrc.prod-pek01.sh"
              swyf="$SPICEWEASELREPO/production.vpc01.pek01-censorship.nodes.yml"               ;;
         dte) akrb="knife_devtest_ew.rb";           aenv="DevTest Europe West"                  ;;
         dts) akrb="knife_sna01_dts.rb";            aenv="OpenStack:DevTest US West SNA01"
              s3cg="$HOME/.s3cfg.sna01.dts";        osrc="$HOME/.dts.openstackrc.devtest-sna01.sh"
              swyf="$SPICEWEASELREPO/devtest.vpc01.sna01.nodes.yml"                             ;;
         dtu) akrb="knife_devtest_uw.rb";           aenv="DevTest US West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/devtest.vpc01.us-west-2.nodes.yml"                         ;;
         nun) akrb="none";                          aenv="None"                                 ;;
         oce) akrb="knife_openstack_corp.rb";       aenv="OpenStack:Corp"                       ;;
         pek) akrb="knife_pek01.rb";                aenv="Asia Pacific PEK01"
              s3cg="$HOME/.s3cfg.pek01";            osrc="$HOME/.pek.openstackrc.prod-pek01.sh"
              swyf="$SPICEWEASELREPO/production.vpc01.pek01.nodes.yml"                          ;;
         pew) akrb="knife_prod_ew.rb";              aenv="Production Europe West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/production.vpc01.eu-west-1.nodes.yml"                      ;;
         pms) akrb="knife_pms.rb";                  aenv="Production Migration Stack"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/production.vpc02.us-west-2.nodes.yml"                      ;;
         pue) akrb="knife_prod_ue.rb";              aenv="Production US East"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/production.vpc01.us-east-1.nodes.yml"                      ;;
         puw) akrb="knife_prod_uw.rb";              aenv="Production US West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/production.vpc01.us-west-2.nodes.yml"                      ;;
         pte) akrb="knife_pubtest_ew.rb";           aenv="PubTest Europe West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/pubtest.vpc01.eu-west-1.nodes.yml"                         ;;
         ptu) akrb="knife_pubtest_uw.rb";           aenv="PubTest US West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/pubtest.vpc01.us-west-2.nodes.yml"                         ;;
         rou) akrb="knife_r5ops_uw.rb";             aenv="R5Ops US West"
              s3cg="";                              osrc=""
              swyf="$SPICEWEASELREPO/r5ops.vpc01.us-west-2.nodes.yml"                           ;;
         sna) akrb="knife_sna01_pts.rb";            aenv="OpenStack:PubTest US West SNA01"
              s3cg="$HOME/.s3cfg.sna01.pts";        osrc="$HOME/.sna.openstackrc.pubtest-sna01.sh"
              swyf="$SPICEWEASELREPO/pubtest.vpc01.sna01.nodes.yml"                             ;;
         w11) akrb="knife_wux01v01.rb";             aenv="OpenStack:Prod Asia Pacific WUX01-VPC01"
              s3cg="$HOME/.s3cfg.wux01v01";         osrc="$HOME/.wux01v01.openstackrc.prod-wux01.sh"
              swyf="$SPICEWEASELREPO/production.vpc01.wux01.nodes.yml"                           ;;
         w12) akrb="knife_wux01v02.rb";             aenv="OpenStack:Prod Asia Pacific WUX01-VPC02"
              s3cg="$HOME/.s3cfg.wux01v02";         osrc="$HOME/.wux01v02.openstackrc.prod-wux01.sh"
              swyf="$SPICEWEASELREPO/production.vpc02.wux01.nodes.yml"                           ;;
         w13) akrb="knife_wux01v03.rb";             aenv="OpenStack:Prod Asia Pacific WUX01-VPC03"
              s3cg="$HOME/.s3cfg.wux01v03";         osrc="$HOME/.wux01v03.openstackrc.prod-wux01.sh"
              swyf="$SPICEWEASELREPO/production.vpc03.wux01.nodes.yml"                           ;;
           *) echo "unknown environment; (known: ccd dte dts dtu nun oce pek pew pms pue puw pte ptu rou sna w11 w12 w13)"; return 2 ;;
      esac
      if [ "$arg" != "nun" ]; then
         export KNIFTLA=$arg
         export KNIFERB=$CHEF/$akrb
         export KNIFENV=$aenv
         export S3CFG=$s3cg
         export SW_YAML_FILE=$swyf
         export OSRC=$osrc
         [ -n "$OSRC" ] && source "$OSRC"
         export AWS_DEFAULT_PROFILE=$arg  # for `aws` (instead of using --profile)
         echo "environment has been set to --> $KNIFENV"
      else
         unset KNIFTLA
         unset KNIFERB
         unset KNIFENV
         unset S3CFG
         unset SW_YAML_FILE
         unset OSRC
         unset AWS_DEFAULT_PROFILE
         #echo "knife environment has been unset"
         echo "environment has been unset"
      fi
      ## I don't want to set this link anymore to force myself to set my environment
      ##(cd $CHEF; ln -fs $akrb $krb)
      if [ "$COLOR_PROMPT" = yes ]; then
         # shellcheck disable=SC2154
         case $arg in
            nun)
               PS1='${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\u@\h\[\033[00m\]:\[\033[01;32m\]\w\[\033[00m\]â”‚\[\033[01;36m\]\$\[\033[00m\] ' ;;
            dte|dts|dtu|rou)
               PS1='\[\033[01;36m\][$KNIFTLA]\[\033[00m\]${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\u@\h\[\033[00m\]:\[\033[01;32m\]\w\[\033[00m\]â”‚\[\033[01;36m\]\$\[\033[00m\] ' ;;
            pte|ptu|oce|sna)
               PS1='\[\033[01;33m\][$KNIFTLA]\[\033[00m\]${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\u@\h\[\033[00m\]:\[\033[01;32m\]\w\[\033[00m\]â”‚\[\033[01;33m\]\$\[\033[00m\] ' ;;
            ccd|pek|pew|pms|pue|puw|w11|w12|w13)
               PS1='\[\033[01;31m\][$KNIFTLA]\[\033[00m\]${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\u@\h\[\033[00m\]:\[\033[01;32m\]\w\[\033[00m\]â”‚\[\033[01;31m\]\$\[\033[00m\] ' ;;
         esac
         # original TCS
         # PS1='\[\033[01;32m\]\u@\h \[\033[01;34m\]\W $ \[\033[00m\]'
      fi
   else
      if [ -n "$KNIFERB" ]; then
         echo "--- $KNIFENV ---"
         echo " KNIFTLA             = '$KNIFTLA'"
         echo " KNIFERB             = '$KNIFERB'"
         echo " KNIFENV             = '$KNIFENV'"
         echo " S3CFG               = '$S3CFG'"
         echo " SW_YAML_FILE        = '$SW_YAML_FILE'"
         echo " OSRC                = '$OSRC'"
         echo " AWS_DEFAULT_PROFILE = '$AWS_DEFAULT_PROFILE'"
         #echo "$KNIFENV (KNIFERB='$KNIFERB')"
      else
         #echo "knife environment not set: KNIFENV='$KNIFENV' (KNIFERB='$KNIFERB')"
         echo "environment not set:"
         echo " KNIFTLA             = '$KNIFTLA'"
         echo " KNIFERB             = '$KNIFERB'"
         echo " KNIFENV             = '$KNIFENV'"
         echo " S3CFG               = '$S3CFG'"
         echo " SW_YAML_FILE        = '$SW_YAML_FILE'"
         echo " OSRC                = '$OSRC'"
         echo " AWS_DEFAULT_PROFILE = '$AWS_DEFAULT_PROFILE'"
      fi
   fi
}

function son {
   # ssh as ubuntu to an server via IP supplied by user
   nip=$1
   if [ -n "$nip" ]; then
      snauc=$(ssh "ubuntu@$nip" -i ~/.ssh/Red5China.pem)
      echo "here's the command:"
      echo "	$snauc"
      read -rp "is this correct? " ans
      if [ "$ans" = "y" ]; then
         echo "ok, running the command"
         eval "$snauc"
      else
         echo "ok, NOT running the command"
      fi
   else
      echo "need to specify an ip"
   fi
}

function sons {
   # ssh as ubuntu to an server via IP using knife
   if knife_env_set; then
      source_ssh_env
      server=$(knife node list -c "$KNIFERB" | \grep "$1")
      nos=$(wc -l <<< "$server")
      if [ "$nos" -gt 1 ]; then
         sai=0
         echo "which server?"
         for srvr in $server; do
            ((sai++))
            echo "	$sai: $srvr"
            server_array[$sai]=$srvr
         done
         read -rp "enter choice (1-$sai): " choice
         if [ "$choice" -gt 0 ] && [ "$choice" -le "$sai" ]; then
            server=${server_array[$choice]}
         else
            echo "seriously?"
            return
         fi
      fi
      # shellcheck disable=SC2116,SC2086
      server=$(echo $server)  # get rid of leading whitespace and color
      server_ip=$(knife node show -a ipaddress "$server" -c "$KNIFERB" | \grep ipaddress | awk '{print $2}')
      echo "$server ($server_ip)"
      #echo "ssh ubuntu@$server_ip -i ~/.ssh/Red5China.pem"
      #ssh ubuntu@$server_ip -i ~/.ssh/Red5China.pem 2> /dev/null
      #ssh -q ubuntu@$server_ip -i ~/.ssh/Red5China.pem
      echo "ssh ubuntu@$server_ip -i ~/.ssh/Red5Community.pem"
      ssh -q "ubuntu@$server_ip" -i ~/.ssh/Red5Community.pem
   fi
}

function update_spiceweasel_repo {
   # set which spiceweasel YAML file to use
   SPICEWEASELREPO=$REPO_DIR/spiceweasel
   cd "$SPICEWEASELREPO" > /dev/null || return
   if hg incoming > /dev/null; then
      echo -n "updating spiceweasel repo... "
      hg pu > /dev/null
      echo "done... "
   else
      echo "spiceweasel repo is up to date"
   fi
   cd - > /dev/null || return
   [ ! -e "$SW_YAML_FILE" ] && echo "No such file: $SW_YAML_FILE"
}


# -------------------- define aliases --------------------

# company common
alias cf="grep '^function .* ' ~/$CO_BA_FILE | awk '{print $2}' | cut -d'(' -f1 | sort | awk -v c=4 'BEGIN{print \"\n\t--- Functions (use \`scof\` to show details) ---\"}{if(NR%c){printf \"  %-18s\",\$2}else{printf \"  %-18s\n\",\$2}}END{print CR}'"
alias scba='source ~/$CO_BA_FILE'
alias scof=showcof
alias vcba='[ -f $COMPANY_SHIT ] && { echo "editing: $COMPANY_SHIT"; vi $COMPANY_SHIT; sba; }'
# company specific
alias cba='echo "comparing ~/.bash_aliases with ${OTHERVM}... "; scp -pq $OTHERVM:/home/praco/.bash_aliases /home/praco/.bash_aliases.other; diff ~/.bash_aliases{,.other}; echo "done"'
alias kcl='kf client list'
alias knl='kf node list'
alias pushba='echo -n "pushing ~/.bash_aliases to $OTHERVM... "; scp -q /home/praco/.bash_aliases $OTHERVM:/home/praco/.bash_aliases; echo "done"'
alias pullba='echo -n "pulling ~/.bash_aliases from $OTHERVM... "; scp -q $OTHERVM:/home/praco/.bash_aliases /home/praco/.bash_aliases; echo "done"'
alias vsy='vi $SW_YAML_FILE'
alias vvaf=~/scripts/verify_vipsnfips.sh

[ -n "$PS1" ] && echo -n "$CO_BA_FILE(ðŸ›‘) "
